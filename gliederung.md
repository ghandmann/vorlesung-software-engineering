# Gliederung
- Einführung
- Versionskontrolle mit git
    - DAG
    - Commit ID
    - Commandline Interface
- Git & GitHub
    - Feature Branch Workflow
    - Issues & Merge Requests
    - Reviews
- Software Projektmanagement
    - Klassische Vorgehensmodelle
        - Wasserfall, V-Modell, Spiralmodell
    - Moderne Vorgehensmodelle
        - Agiles Manifest, SCRUM, Kanban
- Anforderungeanalyse
    - TBD
- Programmierparadigmen
    - Imperative  vs. Deklarativ
        - Imperative: Schritt für Schritt Anleitung (C++/Python/JavaScript)
        - Deklarative: Das will ich! (SQL)
    - Mutablility vs. Immutability
        - Immutable Data Structures
            - Implementierung by call-by-value
                - Teuer bei großen Strukturen
                - Nesting Nicht trivial: Deep-Copy
            - Seiteneffektferei
            - Jede Veränderung erzeugt neue Instanz (vgl. String in Java, C#)
            - Beispiel: Blockchain
        - Mutable Data Structures
            - Implementierung durch call-by-reference
                - Günstig auch für große Strukturen
                - Nesting Trivial: Alles sind Referenzen
            - Seiteneffektbehaftet
            - Änderungen verändern den Wert für alle die eine Referenz haben
            - Beispiel: Adressbuch
    - Funktional vs. Prozedural vs. OOP
        - Funktionale Sprache (Haskell, F#)
            - Pure Functions (Seiteneffektfrei!)
            - Referentielle Transparenz / Memoization
            - Higher Order Functions
            - Rekursion
            - Tail and Head
            - Composition
        - Prozedural
            - Wiederkehrender Code wird in Funktionen (Prozeduren) ausgelagert
            - Daten und Funktionen existieren getrennt von einander
            - Unpure Functions (aka. Seiteneffektbehaftet)
            - Jeder kann jede Funktion aufrufen
        - OOP Sprachen (Java, C#, C++)
            - Modellieren der Welt als Objekte
            - Kapselung der Daten
            - Klassen, Methoden, Vererbung, Interfaces
            - Mehrfachvererbung vs. Interfaces
                - Composition over Inheritence
                - Diamant-Dilemma
            - Polymorphismus
- Domain Driven Design
    - Fachlichkeit über Technik (vgl. Agiles Manifest)
        - Modellieren der Wirklichkeit
        - Vereinfachung durch Abstraktion
        - Die Selbe komplexe Sache kann auf unterschiedliche weise Abstrahiert werden
            - Vgl. Erdball -> Globus -> Karte (Geographie, Politik, ...)
    - Elemente von DDD
        - Ubiquitos Language
                - Finden und definieren einer gemeinsamen Sprache
                - Eigene Voreingenommenheit aufbrechen
                - Mißverständnisse identifizieren bevor sie zum Problem werden
                - Verwenden dieser Sprache bei Kommunikation, Dokumnetation und im Code (Klassenname, Variablennamen, etc.)
        - Bounded Context
            - In der Fachlichkeit existierende Abgrenzungen
            - Identifzieren von Grenzen zwischen den Modellen
            - Erlauben die Verwendunge "der gleiche Sache" in anderem Kontext
            - Erzeugen i.d.R. auch eine Konsistensgrenze, d.H. innerhalb eines Bounded Context kann Konsistenz garantiert werden
                - Konsistenz über Bounded Context Grenzen kann i.d.R. nicht garantiert werden
            - Beispiel: "Auftrag" im Kontext von "Einkauf", "Produktion" und "Marketing"
        - Entities
            - Eindeutig identifizierbar (ID)
            - Haben eine Lebensdauer
            - Sind i.d.R. veränderlich (mutable)
            - Beispiel: Anstellungsverhältnis
        - Value Objects
            - Nicht eindeutig identifizierbar (anonym)
            - Werden häufig wiederverwendet
            - Sind unendlich gültig
            - Sind i.d.R. nicht veränderlich (immutable)
            - Beispiel: Position im Unternehmen (Entwickler, CEO, Hausmeister)
        - Domain Events
            - Ereignisse die in der Fachdomäne vorkommen
            - Beispiel: Mitarbeiter entlassen
        - Aggregate
            - Kapselt Entities und Value Objects
            - Nimmt über Methoden Kommandos entgegenen
            - Stellt die eigene Konsistenz sicher (Invarianzen)
            - Führt Kommandos nur aus, wenn sie im Aktuellen Zustand zulässig sind
            - Emitiert Domain Event(s) als Reaktion auf ein Kommando
    - Event Storming
        - Es wird versucht zu ermitteln welche Ereignisse in der Fachdomäne vorkommen
        - Wie diese Ereeignisse heißen
        - Was passieren muss, dass diese Ereignisse ausgelöst werden
        - Welche Daten diese Ereignisse transportieren
        - Daraus ergeben sich die Domain Events die das Aggregate erzeugt
        - Beispiel: Bewerber Eingestellt, Mitarbeiter Entlassen, Mitarbeiter befördert (Sprache! Kontext!)
    - Domain Story Telling
        - Durch Domain Story Telling soll herausgefunden werden:
            - Welche Bounded Contexts miteinander interagieren (kommunizieren)
            - Welche Informationen (Domain Events, Aggregates, Value Objects) sie austauschen
            - Beispiel:
                - Kandidat bewirbt sich bei HumanResources
                - HumanResourcen bewertet Kandidate
                - HumanResourcen übergibt relevante Kandidaten an Fachabteilung
                - Fachabteilung wählt Kandidate für Vorstellungsgespräch aus
                - HumanResourcen lädt Kandidat und Fachabteilung zum Vorstellungesgespräch ein
    - Event Sourcing
        - Klassische Datenbanken speichern immer nur den ist-Zustand, nicht die Historie die dazu geführt hat
            - Vergleiche: User hat die eMail "epplers@hs-albsig.de", Frage: Welche eMail-Adresse hatte er früher?
        - Bei EventSourcing wird nur die Kette der (Domain) Events gespeichert, daraus lässt sich der Zustand zu jedem beliebigen Zeitpunkt rekonstruieren
        - Aus den Events lassen sich zusätzliche Informationen ableiten:
            - Gibt es User, die öfter als 5 mal ihren Wohnort geändert haben?
            - Gibt es User, die innerhalb von einer Stunde mehrere Bestellungen aufgegeben haben?
            - Welche Bestellungen wurden innerhalb von 10 Minuten storniert?
        - Der Speicherort für diese Events wir EventStore genannt
        - Aus Performance-Gründen werden i.d.R. ReadModels voraus berechnet
            - Beispiel: UserProfile, WatchHistory, WhatToWatchNext
            - Wo Licht ist, ist auch Schatten: Stale ReadModels
    - CQRS
        - Command Query Responsibility Segregation
        - Im wesentlichen die Unterscheiden zwischen schreibendem und lesendem Zugriff
        - Kommandos ändern den Zustand
            - Schlechter Skalierbar da Seiteneffektbehaftet -> evtl. synchronisation notwendig
        - Queries geben nur eine sicht auf den Zustand (View) zurück
            - Gute Skalierbar da Seiteneffektfrei
        - Passt daher sehr gut zu DDD und EventSourcing
            - Commands werden an das Aggregate übergeben
            - Queries werden aus den ReadModels bedient
        
- Softwaretests
    - Manuelles Testen
        - Zeitaufwendig
        - Fehleranfällig
        - Unwirtschaftlich
        - Bereits bei geringen Featureaufwand unmöglich
    - Automatisiertes Testen
        - Schnell(er)
        - Kostengünstig
- Softwarearchitekturen
    - Monolithische
    - Verteilte
    - Layered
    - Event-Driven
- Microservice Pattern
    - Form der Verteilten Architektur
    - Viele kleine Services
    - Typischerweise bildet ein Service einen BoundedContext ab
    - Ermöglicht das freie mischen von Sprachen und Paradigmen: Best fit
    - Komplex, erfordert weiterführende Techniken wie Observerablity, Monitoring, Healthchecking, Alarming
- Design Principles
    - SOLID
    - DRY
- Containervirtualisierung
    - Am Anfang stand da ein Server
        - Für jeden Dienst ein eigener Server (HTTP, Mail, FTP, etc.)
        - Geringe Auslastung der einzelnen Dienste -> Verschwendete Resourcen
    - Hardware Virtualisierung
        - Die selbe Hardware wird mehrfach genutzt
        - Virtuelle Maschine "simuliert" die Hardware
        - Vollständiges Betriebsystem "glaubt" es würde nativ laufen
        - Bessere Auslastung der vorhandenen Hardware
        - Overprovisioning - Was wenn doch mal alle dran kommen wollen?
        - Großer Overhead (Windows Installation >20GB Hdd + XGB RAM)
    - Prozess Virtualisierung aka. Containeriesierung
        - Konzept aus dem Linux Kernel
        - Cgroups: Limitieren von Resourcen (CPU, Arbeitsspeicher, I/O Zugriffe)
        - Namespaces: Steuern von Sichtbarkeit was auf dem System verfügbar ist
            - Namespaces funktionieren wie "Gruppen"
            - Nur die Prozesse im selben Namespace können sich gegenseitig sehen
            - Unterschiedliche Arten von Namespaces:
                - Prozess-Namespace
                - Network-Namespace
                - Mount-Namespace
            - Namespace-Nesting: Von außen kann man reinschauen, von innen aber nicht raus schauen
        - Cgroups & Namespaces => Prozess Virtualisierung
            - Prozesse laufen "isoliert" in einer "sandbox"
            - Prozesse starten und beenden ist günstig (vgl. booten einer VM)
            - Alles läuft auf dem selben Host-Kernel
            - Jeder Prozess sieht aber nur was in seinem "Container" los ist
        - Warum ich vermeide "Docker" zu sagen
            - Hat Containeriesierung populär gemacht
            - Ist aber im wesentlichen eine leere Hülle, eine Marke
            - Alle Container-Relevanten-Technologien und Konzepte sind mittlerweile OpenSource bei der CNCF (Cloud Native Compute Foundation) und oder OCI (Open Container Initiative)
                - Container-Runtime: containerd, crio
                - Image-Format: OCI Image Format
                - Diverse Implementierungn für Image-Repositories (z.B. quay.io, GitLab, GitHub)
                - Alternative Client-Runtimes: z.B. `podman`
            - Docker betreibte nach wie vor viel Infrastruktur
                - hub.docker.com ist immer noch Hauptanlaufpunkt für Images
                    - Wird aber kritischer gesehen, z.B. wegen Rate-Limiting seit April 2025
        - Image vs. Container
            - Das Image ist die Vorlage für einen Container
            - Kann fertig bezogen werden (z.B. hub.docker.com) oder selbst gebaut werden (`Dockerfile`/`Containerfile`)
            - Images sind unveränderlich, viele Container können auf dem selben Image basieren ohne das Konflikte entstehen
            - Im Container gemacht Änderungen fließen nicht zurück ins Image
            - Images bestehen aus Layern
                - Vergleich: Klarsichtfolien
                - Wichtig: Dateien die einmal vorhanden waren, bleiben erhalten
                    - Tool: https://github.com/wagoodman/dive
                - Jedes Layer wird durch einen SHA256 hash identifiziert
                - Es wird eine cryptografische Kette aufgebaut (vgl. git, blockchain)
                - Änderungen in einem tieferen Layer änder auch alle nachfolgenden
                - Hashes werden für caching benutzt: Selber Hash == unverändertes Image/Layer
            - Container sind vergänglich, "aus dem Staub, in den Staub"
                - Daher sollten Container stateless gedacht werden
                - Container können jederzeit aus einem Image neu erzeugt werden
                - Problem: Was wenn doch Daten anfallen? z.B. Datenbanken?
                    - Auslagern der Daten in sog. `volumes`
                        - Wahlweise andere Container
                        - Verzeichnisse auf dem Host-System
        - Erzeugen von Images
            - `Dockerfile`/`Containerfile` [Reference](https://docs.docker.com/reference/dockerfile/)
                - `FROM $BaseImage` / `FROM scratch`
                - Jedes Statement erzeugt ein neues Layer
                    - `RUN ...`
                    - `COPY ...`
            - Images bekommen einen Namen und ein Tag
                - Achtung: `latest` Tag ist ist nicht stabil. 
            - `docker build --tag my-container-image:1.0 .`
            - Der Build-Context
            - `.dockerignore`
        - Images von hub.docker.com oder jeder anderen `$ImageRegistry`
            - Due dilligence: Will ich das Image wirklich benutzen?
                - Effektiv wird Fremdoce auf dem eigenen System ausgeführt!
                - Docker ist nur hoster
                - Typosquatting
            - `docker pull ubuntu:24.04`
            - Fully Qualified Image Name:
                - `ubuntu:24.04` -> `docker.io/library/ubuntu.24.04`
                - `mcr.microsoft.com/vscode/devcontainers/javascript-node:0-16-bullseye`, mcr: Microsoft Container Registry
                - `quay.io/keycloak/keycloak`, quai.io: Red Hat Container Registry
            - Lokale Images Anzeigen: `docker images`
        - Containervirtualisierung ist keine Security Lösung!
            - Jeder Prozess teilt sich den Host-Kernel: Sicherheitslücken im Host-Kernel können auch im Container ausgenutzt werden
                - Worst case: Sandbox-Escape!
            - Wenn ein Container-Prozess als `root` läuft, läuft er wirklich als `root`
            - Alle User die container via `docker` starten dürfen, können effektiv das **GESAMTE** Dateisystem sehen
                - `docker run -it --rm -v /:/host ubuntu:24.04 /bin/bash`
        - Sichere Container-Images:
            - Basis-Image regelmäßig aktualisieren (ist genauso eine dependency wie ein JavaScript Modul) (z.B. Dependabot, Renovate)
            - Container-Scanner einsetzen: [Docker Scout](https://docs.docker.com/scout/), [Trivy](https://trivy.dev)




- Continious Integration, Continious Deployment

- Eher Ausklammern:
    - Domain Driven Design
        - Fachlichkeit über Technik (vgl. Agiles Manifest)
        - Ubitquitos Language
        - Event Storming
        - Bounded Context
    - Microservice Pattern
        - Form der Verteilten Architektur
        - Viele kleine Services
        - Typischerweise bildet ein Service einen BoundedContext ab
        - Ermöglicht das freie mischen von Sprachen und Paradigmen: Best fit
        - Komplex, erfordert weiterführende Techniken wie Observerablity, Monitoring, Healthchecking, Alarming